from flask import Flask, jsonify, request
import pandas as pd
import re
import os
import uuid
import time
import signal
import sys
import logging
from datetime import datetime
from pathlib import Path
from utils.anonimizacao import AnonimizadorOtimizado
from utils.auxiliar import extrair_tabela_md, get_anonimizador, limpar
from utils.auto_setup import setup_environment
from utils.progress_step import send_progress_ws
from utils import progress_step
from flask_socketio import SocketIO

app = Flask(__name__)
app.config['SECRET_KEY'] = 'sua_chave_secreta'

socketio = SocketIO(app, 
                   cors_allowed_origins=["http://localhost:5173", "http://127.0.0.1:5173"],
                   logger=True,
                   engineio_logger=False)
operation_sockets = {}
progress_step.init_progress(socketio, operation_sockets)

try:
    from utils.anonimizacao import AnonimizadorOtimizado
    ANONIMIZACAO_ATIVA = True
    print("M√≥dulo de anonimiza√ß√£o carregado")
except ImportError as e:
    ANONIMIZACAO_ATIVA = False
    print(f"Anonimiza√ß√£o desabilitada: {e}")

# ==========================================
#  INICIALIZA√á√ÉO DO SETUP
# ==========================================

print(" GMV SISTEMA - INICIALIZA√á√ÉO COM LIMPEZA DE CACHE")
print("=" * 60)
print(f" Diret√≥rio de trabalho: {os.getcwd()}")
print(f" Procurando .env em: {os.path.abspath('.env')}")

# Executa setup autom√°tico COM LIMPEZA FOR√áADA
PATH_TRIAGEM, PASTA_DESTINO, PASTA_DAT = setup_environment()

# Verifica√ß√£o final
if not PATH_TRIAGEM or not PASTA_DESTINO:
    print("\n ERRO CR√çTICO: N√£o foi poss√≠vel configurar vari√°veis de ambiente!")
    print(" DEPURA√á√ÉO:")
    print("   1. Verifique se voc√™ tem permiss√£o para criar arquivos neste diret√≥rio")
    print("   2. Verifique se o arquivo .env foi criado corretamente")
    print("   3. Tente executar como administrador")
    print(f"   4. Arquivo .env deveria estar em: {os.path.abspath('.env')}")
    sys.exit(1)

# TESTE FINAL - Confirma que vari√°veis corretas est√£o sendo usadas
print(" TESTE FINAL DE VERIFICA√á√ÉO:")
print("=" * 40)
final_vars = {
    'PATH_TRIAGEM': os.getenv('PATH_TRIAGEM'),
    'PASTA_DESTINO': os.getenv('PASTA_DESTINO'), 
    'PASTA_DAT': os.getenv('PASTA_DAT')
}

for var_name, var_value in final_vars.items():
    print(f"{var_name} = {var_value}")
    
    # Verifica se o caminho √© absoluto ou relativo
    if var_value:
        abs_path = os.path.abspath(var_value)
        print(f"   Caminho absoluto: {abs_path}")

print("\nCONFIRMA√á√ÉO:")
print(f"Cache de vari√°veis antigas foi limpo")
print(f"Arquivo .env atual foi carregado")
print(f"{len([v for v in final_vars.values() if v])} vari√°veis essenciais definidas")
print("=" * 60)

# ==========================================
# üåê CONFIGURA√á√ÉO DO FLASK
# ==========================================

# Importa utils s√≥ depois do setup
try:
    from utils.suspeicao import encontrar_suspeitos
    print("M√≥dulo de suspei√ß√£o carregado")
except ImportError as e:
    print(f"Aviso: M√≥dulo de suspei√ß√£o n√£o encontrado: {e}")
    def encontrar_suspeitos(texto, arquivo):
        return []

# Configura√ß√£o de logging
logging.basicConfig(
    level=logging.INFO,
    format='%(asctime)s - %(levelname)s - %(message)s',
    handlers=[
        logging.FileHandler('server.log'),
        logging.StreamHandler(sys.stdout)
    ]
)
logger = logging.getLogger(__name__)

# Configura√ß√£o CORS
try:
    from flask_cors import CORS
    CORS(app, resources={r"/*": {"origins": ["http://localhost:5173"]}})
    print("CORS configurado")
except ImportError:
    print("flask-cors n√£o instalado - CORS pode n√£o funcionar")

# Log de inicializa√ß√£o
logger.info(f"Servidor Flask iniciando com PID: {os.getpid()}")
logger.info(f"PATH_TRIAGEM: {PATH_TRIAGEM}")
logger.info(f" PASTA_DESTINO: {PASTA_DESTINO}")
logger.info(f" PASTA_DAT: {PASTA_DAT}")

# ==========================================
# üåê ROTAS DA API
# ==========================================

@app.route('/health', methods=['GET'])
def health_check():
    return jsonify({
        "status": "ok",
        "pid": os.getpid(),
        "timestamp": datetime.now().isoformat(),
        "version": "1.0.0",
        "env_vars": {
            "PATH_TRIAGEM": PATH_TRIAGEM,
            "PASTA_DESTINO": PASTA_DESTINO,
            "PASTA_DAT": PASTA_DAT
        }
    }), 200

@app.route('/process-info', methods=['GET'])
def process_info():
    return jsonify({
        "pid": os.getpid(),
        "ppid": os.getppid() if hasattr(os, 'getppid') else None,
        "cwd": os.getcwd(),
        "env_vars": {
            "PATH_TRIAGEM": PATH_TRIAGEM,
            "PASTA_DESTINO": PASTA_DESTINO,
            "PASTA_DAT": PASTA_DAT
        }
    }), 200

@app.route('/triagem', methods=['GET'])
def get_processos():
    logger.info(" Solicita√ß√£o GET /triagem recebida")
    try:
        dados = extrair_tabela_md(PATH_TRIAGEM)
        logger.info(f" Retornando {len(dados)} processos")
        return jsonify(dados)
    except Exception as e:
        logger.error(f" Erro em GET /triagem: {str(e)}")
        return jsonify({'error': str(e)}), 500

@app.route('/triagem/form', methods=['POST'])
def receber_processo_com_markdown():
    print("üìù Solicita√ß√£o POST /triagem/form recebida")
    try:
        data = request.get_json()
        print(f"üìÑ Dados recebidos")
        
        # CRIA O OPERATION_ID PRIMEIRO!
        operation_id = str(uuid.uuid4())
        print(f"üÜî Operation ID gerado: {operation_id}")
        
        def processar_em_background():
            """Processa o documento em background"""
            print(f"üîÑ Iniciando processamento em background para {operation_id}")
            
            # Pequeno delay para dar tempo do frontend se registrar
            time.sleep(1)
            
            # Verifica se o frontend se registrou
            if operation_id not in operation_sockets:
                print(f"‚ö†Ô∏è Frontend ainda n√£o registrado para {operation_id}, aguardando...")
                # Aguarda mais um pouco
                for i in range(5):  # Aguarda at√© 5 segundos
                    time.sleep(1)
                    if operation_id in operation_sockets:
                        break
                    print(f"‚è≥ Aguardando registro... {i+1}/5")
            
            if operation_id not in operation_sockets:
                print(f"‚ùå Frontend n√£o se registrou para {operation_id} ap√≥s 6 segundos")
                # Continua processamento sem progresso
                processar_sem_progresso(data, operation_id)
                return
            
            print(f"‚úÖ Frontend registrado! Iniciando processamento com progresso...")
            
            try:
                # ETAPA 1: VALIDA√á√ÉO INICIAL
                send_progress_ws(operation_id, 1, 'Validando dados do processo...', 10)
                time.sleep(0.5) 
                
                numero = limpar(data.get('numeroProcesso'))
                tema = limpar(data.get('tema'))
                data_dist = limpar(data.get('dataDistribuicao'))
                responsavel = limpar(data.get('responsavel'))
                status = limpar(data.get('status'))
                markdown = limpar(data.get('markdown'))
                comentarios = limpar(data.get('comentarios'))
                dat_base64 = data.get('dat')
                
                # DATA ATUAL AUTOM√ÅTICA - sempre seta data de hoje
                from datetime import datetime
                ultima_att = datetime.now().strftime('%Y-%m-%d')
                
                # Valida√ß√£o b√°sica
                if not numero:
                    send_progress_ws(operation_id, 0, 'Erro: N√∫mero do processo √© obrigat√≥rio', 0)
                    print("‚ùå N√∫mero do processo obrigat√≥rio")
                    return
                
                if not markdown or not numero:
                    send_progress_ws(operation_id, 0, 'Erro: Campos obrigat√≥rios ausentes', 0)
                    logger.warning("‚ö†Ô∏è Campos obrigat√≥rios ausentes")
                    return
                
                logger.info(f"üìÑ Processando processo: {numero}")
                
                # === PASSO 2: BUSCA SUSPEITOS NO TEXTO ORIGINAL ===
                send_progress_ws(operation_id, 2, 'Analisando suspei√ß√£o e impedimento no documento...', 25)
                time.sleep(1)
                
                suspeitos = []
                if markdown and markdown.strip():
                    try:
                        suspeitos = encontrar_suspeitos(markdown, './utils/suspeitos.txt')
                        if suspeitos:
                            for i, suspeito in enumerate(suspeitos, 1):
                                print(f"   {i}. {suspeito}")
                        else:
                            print("   Nenhum suspeito detectado")
                    except Exception as e:
                        print(f"‚ùå Erro na busca de suspeitos: {e}")
                        suspeitos = []
                
                logger.info(f"üîç Suspeitos encontrados: {suspeitos}")

                # === PASSO 3: PREPARANDO ESTRUTURA ===
                send_progress_ws(operation_id, 3, 'Preparando estrutura de arquivos...', 40)
                time.sleep(0.5)
                
                nome_arquivo_base = numero.replace('/', '-')
                os.makedirs(PASTA_DESTINO, exist_ok=True)
                os.makedirs(PASTA_DAT, exist_ok=True)

                caminho_md = os.path.join(PASTA_DESTINO, f"{nome_arquivo_base}.md")
                caminho_dat = os.path.join(PASTA_DAT, f"{nome_arquivo_base}.dat")

                # === PASSO 4: SALVA ARQUIVOS ORIGINAIS ===
                print("üìÅ [PASSO 4] Salvando arquivos originais...")
                
                # Salva markdown se fornecido
                if markdown and markdown.strip():
                    send_progress_ws(operation_id, 4, 'Salvando documento processado...', 55)
                    time.sleep(0.8)
                    with open(caminho_md, 'w', encoding='utf-8') as f:
                        f.write(markdown)
                    print(f"üíæ Markdown salvo: {caminho_md}")
                    logger.info(f"Markdown salvo: {caminho_md}")

                # Salva .dat como base64 se enviado
                if dat_base64 and dat_base64.strip():
                    send_progress_ws(operation_id, 5, 'Salvando arquivo original...', 65)
                    time.sleep(0.5)
                    with open(caminho_dat, 'w', encoding='utf-8') as f:
                        f.write(dat_base64)
                    print(f"üíæ Arquivo DAT salvo: {caminho_dat}")

                # === PASSO 5: ANONIMIZA√á√ÉO AUTOM√ÅTICA OTIMIZADA ===
                print("üîí [PASSO 5] Iniciando anonimiza√ß√£o autom√°tica otimizada...")
                send_progress_ws(operation_id, 6, 'Executando anonimiza√ß√£o autom√°tica...', 75)
                time.sleep(0.7)
                
                arquivos_anonimizados = {}
                total_substituicoes = 0
                tempo_anonimizacao = 0
                
                if ANONIMIZACAO_ATIVA and markdown and markdown.strip():
                    try:
                        inicio = time.time()
                        print(f"üîÑ Executando anonimiza√ß√£o otimizada para processo {numero}")
                        
                        # Usa a inst√¢ncia otimizada do anonimizador
                        anonimizador = get_anonimizador()
                        
                        # Carrega mapeamento de suspeitos (com cache)
                        mapa_suspeitos = anonimizador.carregar_suspeitos_mapeados("utils/suspeitos.txt")
                        
                        # Executa anonimiza√ß√£o otimizada
                        texto_anonimizado, mapa_reverso = anonimizador.anonimizar_com_identificadores(
                            markdown, mapa_suspeitos
                        )
                        
                        # Salva arquivos anonimizados
                        pasta_anon = os.path.join(PASTA_DESTINO, "anonimizados")
                        pasta_mapas = os.path.join(PASTA_DESTINO, "mapas")
                        os.makedirs(pasta_anon, exist_ok=True)
                        os.makedirs(pasta_mapas, exist_ok=True)
                        
                        # Salva texto anonimizado
                        caminho_md_anon = os.path.join(pasta_anon, f"{nome_arquivo_base}_anon.md")
                        with open(caminho_md_anon, "w", encoding="utf-8") as f:
                            f.write(texto_anonimizado)
                        
                        # Salva mapa de substitui√ß√µes se houver
                        caminho_mapa = None
                        if mapa_reverso:
                            caminho_mapa = os.path.join(pasta_mapas, f"{nome_arquivo_base}_mapa.md")
                            with open(caminho_mapa, "w", encoding="utf-8") as f:
                                f.write("| Identificador | Nome Original |\n")
                                f.write("|---------------|----------------|\n")
                                for ident, nome in sorted(mapa_reverso.items()):
                                    f.write(f"| {ident} | {nome} |\n")
                        
                        total_substituicoes = len(mapa_reverso)
                        tempo_anonimizacao = round(time.time() - inicio, 2)
                        
                        arquivos_anonimizados = {
                            "md": caminho_md_anon,
                            "mapa": caminho_mapa if caminho_mapa else None
                        }
                        
                        print(f"‚úÖ Anonimiza√ß√£o conclu√≠da em {tempo_anonimizacao}s")
                        print(f"üìä Total de substitui√ß√µes: {total_substituicoes}")
                        logger.info(f"‚úÖ Anonimiza√ß√£o conclu√≠da: {total_substituicoes} substitui√ß√µes em {tempo_anonimizacao}s")
                        
                    except Exception as e:
                        print(f"‚ùå Erro durante anonimiza√ß√£o otimizada: {e}")
                        logger.error(f"‚ùå Erro durante anonimiza√ß√£o otimizada: {e}")
                        import traceback
                        traceback.print_exc()
                else:
                    if not ANONIMIZACAO_ATIVA:
                        print("‚ÑπÔ∏è Anonimiza√ß√£o desativada")
                    elif not markdown or not markdown.strip():
                        print("‚ÑπÔ∏è Sem conte√∫do markdown para anonimizar")

                # === PASSO 6: ATUALIZA TABELA DE TRIAGEM ===
                send_progress_ws(operation_id, 7, 'Atualizando tabela de triagem...', 90)
                print("üìã [PASSO 6] Atualizando tabela de triagem...")
                time.sleep(0.5)
                
                # Converte lista de suspeitos para string
                suspeitos_str = ', '.join(suspeitos) if suspeitos else ''

                nova_linha = (
                    f"| {numero} "
                    f"| {tema} "
                    f"| {data_dist} "
                    f"| {responsavel} "
                    f"| {status} "
                    f"| {ultima_att} "
                    f"| {suspeitos_str} "
                    f"| {comentarios} |\n"
                )

                if not os.path.exists(PATH_TRIAGEM):
                    print(f"üìÑ Criando novo arquivo de triagem: {PATH_TRIAGEM}")
                    logger.info(f"üìÑ Criando novo arquivo de triagem: {PATH_TRIAGEM}")
                    with open(PATH_TRIAGEM, 'w', encoding='utf-8') as f:
                        f.write("# Tabela de Processos\n\n")
                        f.write("| N¬∫ Processo | Tema | Data da Distribui√ß√£o | Respons√°vel | Status | √öltima Atualiza√ß√£o | Suspeitos | Coment√°rios |\n")
                        f.write("|-------------|------|-----------------------|-------------|--------|----------------------|-----------|-------------|\n")

                with open(PATH_TRIAGEM, 'r', encoding='utf-8') as f:
                    linhas = f.readlines()

                indice_separador = next(
                    (i for i, linha in enumerate(linhas) if re.match(r'^\|\s*-+\s*\|', linha.strip())),
                    None
                )

                if indice_separador is not None:
                    while indice_separador + 1 < len(linhas) and not linhas[indice_separador + 1].strip().startswith('|'):
                        del linhas[indice_separador + 1]
                    linhas.insert(indice_separador + 1, nova_linha)
                else:
                    linhas += [
                        "| N¬∫ Processo | Tema | Data da Distribui√ß√£o | Respons√°vel | Status | √öltima Atualiza√ß√£o | Suspeitos | Coment√°rios |\n",
                        "|-------------|------|-----------------------|-------------|--------|----------------------|-----------|-------------|\n",
                        nova_linha
                    ]

                with open(PATH_TRIAGEM, 'w', encoding='utf-8') as f:
                    f.writelines(linhas)
                
                # === FINALIZA√á√ÉO ===
                send_progress_ws(operation_id, 8, 'Processo adicionado com sucesso!', 100)
                time.sleep(0.5)
                
                print(f"üéâ Processo {numero} salvo com sucesso")
                print(f"    üìä Suspeitos detectados: {len(suspeitos)}")
                print(f"    üîÑ Substitui√ß√µes anonimiza√ß√£o: {total_substituicoes}")
                print(f"    ‚è±Ô∏è Tempo de anonimiza√ß√£o: {tempo_anonimizacao}s")
                print(f"    üìÅ Arquivos anonimizados: {len([a for a in arquivos_anonimizados.values() if a])}")
                
                logger.info(f"‚úÖ Processo {numero} salvo com sucesso")
                
                # Remove da lista de sockets ap√≥s 5 segundos
                import threading
                threading.Timer(5.0, lambda: operation_sockets.pop(operation_id, None)).start()
                
            except Exception as e:
                send_progress_ws(operation_id, 0, f'Erro: {str(e)}', 0)
                print(f"‚ùå Erro no processamento: {e}")
                import traceback
                traceback.print_exc()
        
        def processar_sem_progresso(data, operation_id):
            """Fallback: processa sem enviar progresso (c√≥pia da l√≥gica original)"""
            print(f"üîÑ Processando sem progresso para {operation_id}")
            try:
                numero = limpar(data.get('numeroProcesso'))
                tema = limpar(data.get('tema'))
                data_dist = limpar(data.get('dataDistribuicao'))
                responsavel = limpar(data.get('responsavel'))
                status = limpar(data.get('status'))
                markdown = limpar(data.get('markdown'))
                comentarios = limpar(data.get('comentarios'))
                dat_base64 = data.get('dat')
                
                from datetime import datetime
                ultima_att = datetime.now().strftime('%Y-%m-%d')
                
                if not numero or not markdown:
                    print("‚ùå Campos obrigat√≥rios ausentes")
                    return
                
                # Busca suspeitos
                suspeitos = []
                if markdown and markdown.strip():
                    try:
                        suspeitos = encontrar_suspeitos(markdown, './utils/suspeitos.txt')
                    except Exception as e:
                        print(f"‚ùå Erro na busca de suspeitos: {e}")
                
                # Salva arquivos
                nome_arquivo_base = numero.replace('/', '-')
                os.makedirs(PASTA_DESTINO, exist_ok=True)
                os.makedirs(PASTA_DAT, exist_ok=True)
                
                if markdown and markdown.strip():
                    caminho_md = os.path.join(PASTA_DESTINO, f"{nome_arquivo_base}.md")
                    with open(caminho_md, 'w', encoding='utf-8') as f:
                        f.write(markdown)
                
                if dat_base64 and dat_base64.strip():
                    caminho_dat = os.path.join(PASTA_DAT, f"{nome_arquivo_base}.dat")
                    with open(caminho_dat, 'w', encoding='utf-8') as f:
                        f.write(dat_base64)
                
                # Atualiza tabela (vers√£o simplificada)
                suspeitos_str = ', '.join(suspeitos) if suspeitos else ''
                nova_linha = f"| {numero} | {tema} | {data_dist} | {responsavel} | {status} | {ultima_att} | {suspeitos_str} | {comentarios} |\n"
                
                # Salva na tabela (l√≥gica simplificada)
                if not os.path.exists(PATH_TRIAGEM):
                    with open(PATH_TRIAGEM, 'w', encoding='utf-8') as f:
                        f.write("# Tabela de Processos\n\n")
                        f.write("| N¬∫ Processo | Tema | Data da Distribui√ß√£o | Respons√°vel | Status | √öltima Atualiza√ß√£o | Suspeitos | Coment√°rios |\n")
                        f.write("|-------------|------|-----------------------|-------------|--------|----------------------|-----------|-------------|\n")
                        f.write(nova_linha)
                else:
                    with open(PATH_TRIAGEM, 'a', encoding='utf-8') as f:
                        f.write(nova_linha)
                
                print(f"‚úÖ Processo {numero} salvo (sem progresso)")
                
            except Exception as e:
                print(f"‚ùå Erro no processamento sem progresso: {e}")
        
        # Inicia processamento em background
        import threading
        thread = threading.Thread(target=processar_em_background)
        thread.daemon = True
        thread.start()
        
        # Retorna imediatamente para o frontend
        resultado_inicial = {
            "message": "Processamento iniciado",
            "operation_id": operation_id
        }
        
        return jsonify(resultado_inicial), 202  # 202 = Accepted
        
    except Exception as e:
        print(f"‚ùå Erro em POST /triagem/form: {str(e)}")
        import traceback
        traceback.print_exc()
        return jsonify({'error': str(e)}), 500

@app.route('/triagem/<numero>', methods=['PUT'])
def editar_processo(numero):
    print(f" Solicita√ß√£o PUT /triagem/{numero} recebida")
    logger.info(f" Solicita√ß√£o PUT /triagem/{numero} recebida")
    try:
        data = request.get_json()
        print(f" Dados recebidos: {data}")
        
        # Extrai processos existentes
        processos = extrair_tabela_md(PATH_TRIAGEM)
        
        # Encontra o processo existente para preservar suspeitos se necess√°rio
        processo_existente = next((p for p in processos if p['numeroProcesso'] == numero), None)
        suspeitos_existentes = processo_existente.get('suspeitos', '') if processo_existente else ''
        
        # Remove o processo antigo da lista
        processos = [p for p in processos if p['numeroProcesso'] != numero]
        
        # DATA ATUAL AUTOM√ÅTICA - sempre seta data de hoje para √∫ltima atualiza√ß√£o
        from datetime import datetime
        ultima_att = datetime.now().strftime('%Y-%m-%d')
        print(f" √öltima atualiza√ß√£o autom√°tica: {ultima_att}")
        
        # Determina como lidar com suspeitos
        markdown = data.get('markdown', '')
        suspeitos_calculados = ''
        
        if markdown and markdown.strip():
            # Se h√° markdown novo, recalcula suspeitos
            try:
                suspeitos_lista = encontrar_suspeitos(markdown, './utils/suspeitos.txt')
                suspeitos_calculados = ', '.join(suspeitos_lista) if suspeitos_lista else ''
                print(f" Suspeitos recalculados: {suspeitos_calculados}")
            except Exception as e:
                print(f" Erro ao calcular suspeitos: {e}")
                suspeitos_calculados = suspeitos_existentes
        else:
            # Se n√£o h√° markdown, mant√©m suspeitos existentes
            suspeitos_calculados = suspeitos_existentes
            print(f" Mantendo suspeitos existentes: {suspeitos_calculados}")
        
        # Salva markdown atualizado se fornecido
        if markdown and markdown.strip():
            nome_arquivo_base = numero.replace('/', '-')
            os.makedirs(PASTA_DESTINO, exist_ok=True)
            caminho_md = os.path.join(PASTA_DESTINO, f"{nome_arquivo_base}.md")
            
            with open(caminho_md, 'w', encoding='utf-8') as f:
                f.write(markdown)
            print(f" Markdown atualizado: {caminho_md}")
        
        # Salva arquivo DAT se fornecido
        dat_base64 = data.get('dat')
        if dat_base64 and dat_base64.strip():
            nome_arquivo_base = numero.replace('/', '-')
            os.makedirs(PASTA_DAT, exist_ok=True)
            caminho_dat = os.path.join(PASTA_DAT, f"{nome_arquivo_base}.dat")
            
            with open(caminho_dat, 'w', encoding='utf-8') as f:
                f.write(dat_base64)
            print(f"Arquivo DAT atualizado: {caminho_dat}")
        
        # Cria o processo atualizado (SEMPRE usa data atual para √∫ltima atualiza√ß√£o)
        processo_atualizado = {
            "numeroProcesso": limpar(data['numeroProcesso']),
            "tema": limpar(data['tema']),
            "dataDistribuicao": limpar(data['dataDistribuicao']),  # Mant√©m a data original
            "responsavel": limpar(data['responsavel']),
            "status": limpar(data['status']),
            "ultimaAtualizacao": ultima_att,  # SEMPRE data atual
            "suspeitos": suspeitos_calculados,
            "comentarios": limpar(data.get('comentarios', ''))
        }
        
        # Adiciona o processo atualizado √† lista
        processos.append(processo_atualizado)
        
        # Reescreve o arquivo de triagem
        with open(PATH_TRIAGEM, 'w', encoding='utf-8') as f:
            f.write("# Tabela de Processos\n\n")
            f.write("| N¬∫ Processo | Tema | Data da Distribui√ß√£o | Respons√°vel | Status | √öltima Atualiza√ß√£o | Suspeitos | Coment√°rios |\n")
            f.write("|-------------|------|-----------------------|-------------|--------|----------------------|-----------|-------------|\n")
            f.write("|-------------|------|-----------------------|-------------|--------|----------------------|-----------|-------------|\n")
            for p in processos:
                f.write(
                    f"| {p['numeroProcesso']} | {p['tema']} | {p['dataDistribuicao']} | {p['responsavel']} "
                    f"| {p['status']} | {p['ultimaAtualizacao']} | {p['suspeitos']} | {p.get('comentarios', '')} |\n"
                )

        print(f" Processo {numero} atualizado com sucesso")
        logger.info(f" Processo {numero} atualizado com sucesso")
        return jsonify({"message": "Processo atualizado com sucesso"}), 200

    except KeyError as e:
        print(f" Campo obrigat√≥rio ausente em PUT /triagem/{numero}: {str(e)}")
        return jsonify({'error': f'Campo obrigat√≥rio ausente: {str(e)}'}), 400
    except Exception as e:
        print(f" Erro em PUT /triagem/{numero}: {str(e)}")
        logger.error(f" Erro em PUT /triagem/{numero}: {str(e)}")
        return jsonify({'error': str(e)}), 500

@app.route('/triagem/<numero>', methods=['DELETE'])
def deletar_processo(numero):
    logger.info(f"üóëÔ∏è Solicita√ß√£o DELETE /triagem/{numero} recebida")
    try:
        processos = extrair_tabela_md(PATH_TRIAGEM)
        processos = [p for p in processos if p['numeroProcesso'] != numero]

        with open(PATH_TRIAGEM, 'w', encoding='utf-8') as f:
            f.write("# Tabela de Processos\n\n")
            f.write("| N¬∫ Processo | Tema | Data da Distribui√ß√£o | Respons√°vel | Status | √öltima Atualiza√ß√£o | Suspeitos | Coment√°rios |\n")
            f.write("|-------------|------|-----------------------|-------------|--------|----------------------|-----------|-------------|\n")
            for p in processos:
                f.write(
                    f"| {p['numeroProcesso']} | {p['tema']} | {p['dataDistribuicao']} | {p['responsavel']} "
                    f"| {p['status']} | {p['ultimaAtualizacao']} | {p['suspeitos']} | {p.get('comentarios', '')} |\n"
                )

        caminho_md = os.path.join(PASTA_DESTINO, f"{numero.replace('/', '-')}.md")
        if os.path.exists(caminho_md):
            os.remove(caminho_md)
            logger.info(f" Arquivo markdown removido: {caminho_md}")

        logger.info(f" Processo {numero} exclu√≠do com sucesso")
        return jsonify({"message": "Processo exclu√≠do com sucesso"}), 200

    except Exception as e:
        logger.error(f" Erro em DELETE /triagem/{numero}: {str(e)}")
        return jsonify({'error': str(e)}), 500

@app.route('/triagem/<numero>/dat', methods=['GET'])
def obter_dat(numero):
    logger.info(f" Solicita√ß√£o GET /triagem/{numero}/dat recebida")
    try:
        nome_arquivo = f"{numero.replace('/', '-')}.dat"
        caminho = os.path.join(PASTA_DAT, nome_arquivo)

        if not os.path.exists(caminho):
            logger.warning(f" Arquivo DAT n√£o encontrado: {caminho}")
            return jsonify({'error': 'Arquivo .dat n√£o encontrado'}), 404

        with open(caminho, 'r', encoding='utf-8') as f:
            dat_base64 = f.read()

        logger.info(f"Arquivo DAT retornado: {caminho}")
        return jsonify({'base64': dat_base64}), 200

    except Exception as e:
        logger.error(f" Erro em GET /triagem/{numero}/dat: {str(e)}")
        return jsonify({'error': str(e)}), 500
    
@app.route('/debug/sockets')
def debug_sockets():
    """Debug dos sockets ativos"""
    return jsonify({
        'active_sockets': operation_sockets,
        'socket_count': len(operation_sockets),
        'keys': list(operation_sockets.keys())
    })

@app.route('/debug/test-progress/<operation_id>')
def test_progress(operation_id):
    """Testa envio de progresso manualmente"""
    from utils.progress_step import send_progress_ws
    
    send_progress_ws(operation_id, 2, 'Teste manual de progresso', 50)
    
    return jsonify({
        'message': f'Progresso teste enviado para {operation_id}',
        'socket_registered': operation_id in operation_sockets,
        'socket_id': operation_sockets.get(operation_id, 'N√£o encontrado')
    })

# ==========================================
# üîÑ FINALIZA√á√ÉO E EXECU√á√ÉO
# ==========================================

def signal_handler(sig, frame):
    logger.info(f" Sinal {sig} recebido. Finalizando servidor graciosamente...")
    logger.info(f" Servidor com PID {os.getpid()} finalizado")
    sys.exit(0)

# Registra os handlers de sinal
signal.signal(signal.SIGTERM, signal_handler)
signal.signal(signal.SIGINT, signal_handler)

@socketio.on('connect')
def handle_connect():
    print(f'‚úÖ Cliente WebSocket conectado: {request.sid}')
    
@socketio.on('start_listening')
def handle_start_listening(data):
    print(f"üì• Evento start_listening recebido")
    print(f"üìä Dados: {data}")
    print(f"üìç Socket ID: {request.sid}")
    
    operation_id = data.get('operation_id')
    
    if operation_id:
        operation_sockets[operation_id] = request.sid
        print(f"‚úÖ Registrado: {operation_id} -> {request.sid}")
        print(f"üìä Sockets ativos agora: {operation_sockets}")
        
        # Confirma registro
        socketio.emit('progress_update', {
            'step': 1,
            'message': 'Canal de progresso ativo! Aguardando processamento...',
            'percentage': 5,
            'operation_id': operation_id,
            'error': False
        }, to=request.sid)
        
        print(f"üì§ Confirma√ß√£o enviada para {request.sid}")
        
    else:
        print("‚ùå operation_id ausente!")
        socketio.emit('error', {'message': 'operation_id √© obrigat√≥rio'}, to=request.sid)

@socketio.on('disconnect')
def handle_disconnect():
    print(f'‚ùå Cliente WebSocket desconectado: {request.sid}')
    # Remove das opera√ß√µes ativas
    to_remove = [op_id for op_id, sid in operation_sockets.items() if sid == request.sid]
    for op_id in to_remove:
        operation_sockets.pop(op_id, None)
    print(f"üßπ Removidas {len(to_remove)} opera√ß√µes do cliente")

if __name__ == '__main__':
    try:
        print(f"\n SERVIDOR GMV SISTEMA PRONTO!")
        print("=" * 40)
        print(f" URL: http://127.0.0.1:5000")
        print(f" Health: http://127.0.0.1:5000/health")
        print(f" Info: http://127.0.0.1:5000/process-info")
        print(f" Dados: {os.path.abspath(os.path.dirname(PATH_TRIAGEM))}")
        print("=" * 40)
        print(f" USANDO AS SEGUINTES CONFIGURA√á√ïES:")
        print(f"   PATH_TRIAGEM: {PATH_TRIAGEM}")
        print(f"   PASTA_DESTINO: {PASTA_DESTINO}")
        print(f"   PASTA_DAT: {PASTA_DAT}")
        print("=" * 40)

        logger.info(f"Iniciando servidor Flask na porta 5000 com PID: {os.getpid()}")
        
        
        # CORRETO PARA SUPORTE A SOCKET.IO
        socketio.run(app, debug=True, port=5000, host='127.0.0.1')

    except Exception as e:
        logger.error(f"Erro ao iniciar servidor: {e}")
        print(f"\n ERRO CR√çTICO: {str(e)}")
        sys.exit(1)
